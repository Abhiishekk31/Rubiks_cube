1.Representing/modelling the cube in code:
	a.How to take an input
	b.18 Basic Operations
	c.Print
	d..

1-2.Solvable (Out of scope for this project)

2.Solving it:
	a.output the min steps required to solve it


Store a Rubiks Cube
1. 3d array -> ((3*3)matrix)*6 
2. 1d array -> linearise the 3d array


## why do we need abstract class
--we write a solver for generic class and it can solve for all the children class
--to maintain consistency across models


[bfs solver  , DDFS solver , DFS solve] ->  abstract class -> [3d model, 1d model, bit board model]

## how do you get shuffled rubiks cube
-- Take 3*3*6 colors and add it anywhere? (maynot turn out to be Solvable)
-- start from a solved rubiks cube and do some number of random Operations (this will guarantee the rubiks cube is Solvable)


## do we need to implement the random shuffle method in abstract class or derived class?
-- if in abstract class, then how?
Just use already declared 18 rotations


## header file .h
--HOW?
--signature declaration

##cpp file
--WHAT?
--- actual implementation

##enum
-- Data Type
-- Option step for ex: color {r,g,b,...}


##run command
g++ -std=c++14 main.cpp Model/RubiksCube.cpp Model/RubiksCube3dArray.cpp -o cube
./cube


